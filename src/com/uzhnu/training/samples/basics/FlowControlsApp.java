package com.uzhnu.training.samples.basics;

import java.util.Random;

/**
 * <p>У цьому лістингу пояснюються оператори для побудови алгоритмів (розгалуження і цикли)</p>
 *
 * @author Paul Danyliuk
 * @version $Id$
 */
public class FlowControlsApp {

    /*
    Кожна програма - це, зрештою, набір якихось дій, які виконуються одна за іншою.
    Послідовність дій називається АЛГОРИТМОМ.

    Найпростіший вид алгоритмів - лінійні. Це коли усі дії виконуються одна за іншою від початку програми і до кінця.
    Приклад - програма, яка зчитує Ваше ім’я, Ваш вік і виводить привітання (com.uzhnu.training.samples.HelloApp)

    Проте від лінійних програм користі небагато. Якби калькулятор був лінійним, він би підтримував лише одну операцію,
    і після закінчення обчислень закрився би. Нормальний калькулятор, який підтримує принаймні віднімання, додавання,
    множення і ділення, повинен виконувати різні обчислення в залежності від вибраної користувачем операції: якщо
    користувач натиснув плюс, то треба виконати і вивести суму, якщо мінус - різницю і т.д. Окрім того, нормальний
    калькулятор дозволятиме користувачу робити нові обчислення аж поки користувач його не вимкне (на комп’ютері -
    не натисне кнопку «вихід»).

    Алгоритми, у яких різні дії виконуються або не виконуються залежно від умов, називаються розгалуженими, а шматки
    алгоритму із такими діями - гілками. Програма може виконати одну або іншу гілку, і далі повернутися до спільного
    продовження.

    Алгоритми, у яких дії виконуються знову і знову, називаються циклічними, а шматки алгоритму із такими діями -
    циклами. Цикл може виконуватися скінченну або нескінченну кількість разів - це теж задається умовами.

    Загляньте у com.uzhnu.training.samples.RandomApp - гру, в якій комп’ютер загадує число від 1 до 100, а Вам потрібно
    відгадати його, керуючись підказками. У цій програмі є і цикл, і розгалуження. Цикл тут полягає в тому, що програма
    виконує БЛОК КОДУ (зчитує Ваше число і повідомляє про результат) знову і знову, аж доки Ви не вгадаєте число.
    А розгалуження має три гілки: якщо Ваш варіант менший за загадане число (одна підказка), якщо більший
    (інша підказка), і якщо Ви вгадали число (привітання і вихід із програми).

    Цикли і розгалуження створюються відповідно операторами циклу і операторами розгалуження, які разом мають назву
    операторів потоку керування (control flow operators).

    Фактично, маючи у своєму розпорядженні змінні, масиви, операції над даними, цикли і розгалуження, можна
    запрограмувати розв’язування будь-якої задачі. Можливості деяких академічних мов на цьому і закінчуються.
    */

    public static void main(String[] args) {

        // Щоб було цікавіше, «кинемо» два кубики:
        Random random = new Random();
        int die1 = random.nextInt(6) + 1;        // nextInt(5) генерує ціле число від 0 до 5 включно,
        int die2 = random.nextInt(6) + 1;        // тож щоб отримати від 1 до 6, треба додати одиницю

        System.out.println("На першому кубику випало " + die1 + ", а на другому - " + die2);

        // Тепер кожного разу як Ви запускатимете цю програму, вона працюватиме одним із 36 різних шляхів

        // -------------------------------------------------------------------------------------------------------------

        // 1. Розгалуження
        // У Java та інших сі-подібних мовах є три способи зробити розгалуження.
        // Найпростіший і найбільш поширений - за допомогою оператора if («якщо»), і пишеться так:
        //
        // if (<умова, яка повертає boolean>) {
        //     <код, який виконається, якщо умова true>
        // }

        if (die1 == die2) {
            System.out.println("На кубиках випали однакові числа!");
        }
        // Якщо умова не виконалася (випали різні числа) -
        // програма пропустить цей блок (не виведе повідомлення) і піде далі.

        // -------------------------------------------------------------------------------------------------------------

        // Якщо потрібно виконати якісь альтернативні дії, коли умова НЕ виконалася,
        // використовують оператор else («інакше»):

        if (die1 % 2 == 0) {
            // Умова перевіряє, що число die1 ділиться на 2 без остачі
            System.out.println("На першому кубику випало парне число");
        } else {
            // У всіх інших випадках (точніше, єдиному випадку, коли остача від ділення на 2 буде 1):
            System.out.println("На першому кубику випало непарне число");
        }

        // Але, як показано у попередньому прикладі, блок else не є обов’язковим

        // -------------------------------------------------------------------------------------------------------------

        // Умови можна вкладати одна в одну як завгодно глибоко

        if (die1 < 4) {
            System.out.println("На першому кубику випало від 1 до 3");

            if (die2 < 4) {
                System.out.println("І на другому кубику випало від 1 до 3");
            } else {
                System.out.println("А на другому кубику випало від 4 до 6");
            }
        } else {
            System.out.println("На першому кубику випало від 4 до 6");

            if (die2 < 4) {
                System.out.println("А на другому кубику випало від 1 до 3");
            } else {
                System.out.println("І на другому кубику випало від 4 до 6");
            }
        }

        // -------------------------------------------------------------------------------------------------------------

        // Гілок може бути більше ніж одна. Такі умови задаються послідовно
        // Перевірка умов виконуватиметься по черзі; виконається тільки перший блок, чия умова дорівнюватиме true:

        if (die1 == 1) {
            System.out.println("На першому кубику випало число 1");
        } else if (die1 == 2) {
            System.out.println("На першому кубику випало число 2");
        } else if (die1 == 3) {
            System.out.println("На першому кубику випало число 3");
        } else if (die1 < 4) {
            // Цей блок ніколи не виконається, навіть якщо на кубику випало число менше 4,
            // адже ці варіанти уже перехопили попередні умови

            System.out.println("Я ніколи не виконаюсь!");
        }
        // Тут може бути else - для коду, який виконається, коли випало число від 4 до 6.

        // -------------------------------------------------------------------------------------------------------------

        // Фактично, ці два останні розгалуження можна переписати на рівноцінні:

        // Вкладене на послідовне:
        if (die1 < 4 && die2 < 4) {                                            // пам’ятаємо про ЛОГІЧНЕ І?
            System.out.println("На першому кубику випало від 1 до 3");
            System.out.println("І на другому кубику випало від 1 до 3");
        } else if (die1 < 4 && die2 >= 4) {
            System.out.println("На першому кубику випало від 1 до 3");
            System.out.println("А на другому кубику випало від 4 до 6");
        } else if (die1 >= 4 && die2 < 4) {
            System.out.println("На першому кубику випало від 4 до 6");
            System.out.println("А на другому кубику випало від 1 до 3");
        } else {                                                               // бо більше не лишилося варіантів
            System.out.println("На першому кубику випало від 4 до 6");
            System.out.println("І на другому кубику випало від 4 до 6");
        }

        // Послідовне на вкладене (насправді, змінилося лише форматування і з’явилися фігурні дужки):
        if (die1 == 1) {
            System.out.println("На першому кубику випало число 1");
        } else {
            if (die1 == 2) {
                System.out.println("На першому кубику випало число 2");
            } else {
                if (die1 == 3) {
                    System.out.println("На першому кубику випало число 3");
                } else {
                    if (die1 < 4) {
                        System.out.println("Я ніколи не виконаюсь!");
                    }
                }
            }
        }

        // Як бачите, одну і ту саму логіку можна описати різними способами, тому Ви як програміст повинні приймати
        // рішення, як скласти умову найефективнішим шляхом, і щоб не було ЛАЙНОКОДУ.

        // Порівняйте рівноцінні приклади між собою, і Ви побачите, що приклад із перевіркою на 1-2-3 читається набагато
        // легше коли умови йдуть одна за одною, а не вкладені, а приклад із двома кубиками краще зробити вкладеним,
        // оскільки у іншому випадку виконується набагато більше операцій і є повторення коду.

        // Цікаво знати: насправді, на рівні процесора навіть послідовні розгалуження виконуються як вкладені.
        // Але це не має значення.
        // Зрозумілість і простота коду повинні завжди бути ПРІОРИТЕТОМ НОМЕР 1 !!!

        // -------------------------------------------------------------------------------------------------------------

        // Інший спосіб задання розгалуження - оператор switch/case («перемикач»/«у випадку»).
        // Його синтаксис виглядає наступним чином:

        switch (die2) {
            case 1:
                System.out.println("На другому кубику випало число 1");
                // тут можуть бути інші операції - зверніть увагу, що гілки не обгорнуті у фігурні дужки
                // ...
                break;      // Щоб не спрацювали інші гілки, у кінці «блоку» case треба поставити оператор break!
            case 4:
                System.out.println("На другому кубику випало число 4");
                break;
            case 2:         // Таким чином можна об’єднувати кілька варіантів
            case 3:
                System.out.println("На другому кубику випало 2 або 3");
                break;
            default:
                // Аналогічно до else, блок default іде останнім, виконується тоді, коли не виконалося нічого зверху
                // і може бути відсутнім.
                System.out.println("На другому кубику випало не 1, не 2, не 3 і не 4");
        }
        // У останньому блоку оператор break необов’язковий

        // Як це розуміти?
        // Для значення switch перевіряється його рівність посліднвно кожному зі значень case.
        // Як тільки Java знайде збіг, вона виконуватиме ВЕСЬ код до кінця блоку switch, не зважаючи на інші case.
        // Оператор break зупиняє виконання коду в даному блоці і зумовлює вихід із нього (із блоку).
        // Звісно, break можна і не ставити, якщо це саме те, що Вам потрібно:
        switch (die1) {
            case 1:
                System.out.println("На першому кубику випало 1 або більше");
            case 2:
                System.out.println("На першому кубику випало 2 або більше");
            case 3:
                System.out.println("На першому кубику випало 3 або більше");
            case 4:
                System.out.println("На першому кубику випало 4 або більше");
            case 5:
                System.out.println("На першому кубику випало 5 або більше");
            case 6:
                System.out.println("На першому кубику випало 6 або більше");
        }

        // Оператори switch/case працюють із такими типами даних:
        // - цілочисельними примітивами: byte, short, int (але не long)
        // - літерами (char)
        // - класами-обгортками над цими примітивами (Character, Byte, Short, Integer)
        // - класами-перечисленнями (енумераторами) - їх ми ще не розглядали
        // - починаючи із Java 7 - рядками (String)

        // Знову ж таки, вибір між розгалуженнями if/else і switch/case Ви здійснюєте на власний розсуд,
        // в залежності від того, який код краще сприймається.

        // -------------------------------------------------------------------------------------------------------------

        // Третій спосіб створення розгалужень - тернарний оператор ?: (умовний оператор)
        // Досі ми розглядали унарні оператори (один операнд) типу i++ і бінарні оператори (два операнди) типу a + b
        // Тернарні оператори приймають ТРИ операнди, і насправді я не знаю, чи існують інші тернарні оператори крім ?:

        // Умовний оператор повертає одне зі значень в залежності від умови. Синтаксис виглядає так:
        // <умова, яка повертає boolean> ? <значення, якщо true> : <значення, якщо false>
        System.out.println(die1 == die2 ? "рівні" : "різні");

        int difference = die1 > die2 ? die1 - die2 : die2 - die1;   // Якщо значення першого кубика більше за значення
                                                                    // другого - відняти від першого друге, інакше -
                                                                    // від другого перше.
        System.out.println("Різниця між значеннями кубиків - " + difference);

        // Тернарний оператор можна використовувати каскадом (один в іншому):
        System.out.println(
                die1 == die2 ? "рівні" : die1 > die2 ? "перший більше" : "другий більше"
        );

        // Як бачите, такий оператор хоч і дозволяє компактно записати умову, об такі вирази буває легко зламати очі.
        // Тому використовувати цей оператор треба дуже обережно, там де він дійсно полегшить розуміння коду.

        // -------------------------------------------------------------------------------------------------------------

        // 2. Цикли
        // Суть: блок коду виконується знову і знову поки задовільняється умова циклу.

        // Один прохід коду в циклі називається ІТЕРАЦІЄЮ.
        // Тобто, якщо код у циклі виконався 10 разів, кажуть, що цикл пройшов 10 ітерацій
        // (перша ітерація, друга ітерація і т.д.)

        // У Java та інших сі-подібних мовах є три основні типи циклів:
        // цикл із передумовою, цикл із післяумовою і цикл з параметром.

        // -------------------------------------------------------------------------------------------------------------

        // Цикл з передумовою: умова зазначається на початку циклу і перевіряється ПЕРЕД кожною ітерацією.
        // Умова задається оператором while (англ. «доки»):
        int age = 0;
        while (age < 6) {                // Доки вік < 6
            System.out.println("Вам " + age + " років, Вам ще рано іти в школу.");

            // Збільшимо вік на 1
            age++;
            System.out.println("(пройшов рік)");
        }
        // Цей цикл виконається 6 разів (поки вік буде від 0 до 5 років).
        // Коли вік сягне 6 років, умова age < 6 поверне false, і програма вийде з циклу.

        // Якщо умова не виконується одразу же, програма пропустить цикл взагалі:

        System.out.println("Після першого циклу Вам " + age + " років.");      //6
        while (age < 3) {
            System.out.println("Вам " + age + " років, Вам ще рано іти в дитсадок (але я і так не виконаюсь)");
            age++;
        }
        System.out.println("Після другого циклу (який не виконається) Вам все ще " + age + " років.");     //6

        // -------------------------------------------------------------------------------------------------------------

        // Цикл з післяумовою: умова зазначається в кінці циклу і перевіряється ПІСЛЯ кожної ітерації.
        // На відміну від циклу з післяумовою, у цього циклу відбудеться ПРИНАЙМНІ ОДНА ітерація.
        // Цикл задається операторами do {...} while (англ. «робити ... доки»):
        System.out.println("Кидаємо третій кубик, доки не випаде таке число, як на першому:");
        int die3;
        do {
            die3 = random.nextInt(6) + 1;
            System.out.println("Випало значення " + die3);
        } while (die3 != die1);                                 // Повторювати, доки значення на 1 і 3 кубиках не рівні

        // Цикл з післяумовою може стати в нагоді тоді, коли дію потрібно виконати принаймні один раз,
        // перш ніж можна буде говорити про виконання чи невиконання умови (як у прикладі з третім кубиком).

        // Проте насправді цей тип циклу використовується дуже рідко - зазвичай необхідна задача виконується легше
        // за допомогою нескінченного циклу з передумовою і оператором виходу з циклу.

        // -------------------------------------------------------------------------------------------------------------

        // Цикл з параметром (цикл for): подібний на цикл із передумовою, але є більш гнучким.
        // Складається із трьох інструкцій:
        // - ініціалізація - те, що виконається перед початком циклу. Зазвичай тут оголошується параметр циклу.
        // - термінація    - умова, як і у циклі while: перевіряється перед ітерацією, і якщо вона false,
        //                   відбувається вихід із циклу. Зазвичай тут перевіряють, чи параметр досі знаходиться
        //                   у потрібних межах.
        // - інкремент     - інструкція, яка виконується після кожної ітерації; називається так тому що зазвичай
        //                   тут відбувається інкрементація параметра, тобто збільшення його на одиничку.

        // Задається цей цикл так: for (<ініціалізація>; <термінація>; <інкремент>) {...}
        // Зверніть увагу, що інструкції тут розділяються крапками з комою

        for (int i = 0; i < 10; i++) {          // створити параметр і = 0; повторювати цикл поки i < 10;
                                                // після кожної ітерації збільшувати значення і на 1
            System.out.println("i = " + i);
        }

        // Найчастіше такий тип циклу використовують тоді, коли необхідно здійснити якусь дію задану кількість разів.
        // Ось цей останній цикл, наприклад, пройде 10 ітерацій. Запам’ятайте його як шаблон - Ви використовуватимете
        // його частіше ніж думаєте.

        // Так само як і з циклом while, якщо умова одразу повертає false, цикл не виконується взагалі:
        for (int i = 10; i < 10; i++) {
            System.out.println("Я не виконаюсь");
        }

        // Часто параметр циклу називають літерою i - скорочено від «індекс» або «ітератор».
        // Якщо літера i зайнята, використовують літери j, k, l... Як у математиці, коротше.
        // Або якщо ця змінна має особливе значення, її можна назвати відповідно.

        // -------------------------------------------------------------------------------------------------------------

        // Цикли, як і розгалуження, можна вкладувати один в одного як завгодно, а також цикли в розгалуження
        // і розгалуження в цикли.
        if (die1 - die3 == 0) {
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    // Цикл в циклі: спершу j пробіжиться від 0 до 3 при i = 0, потім знову при i = 1, і знову при i = 2
                    System.out.println(String.valueOf(i) + String.valueOf(j) + " ");
                }
            }
        }
        // виведе: 00 01 02 10 11 12 20 21 22

        // Проте пам’ятайте, що чим більша вкладеність, тим складніший є алгоритм
        // і для комп’ютера, і для людського сприйняття

        // -------------------------------------------------------------------------------------------------------------

        // Оголошений в умові циклу параметр (int i = ...) існує тільки в межах цього циклу.
        // Коли цикл закінчується, ця змінна видаляється:
        for (int i = 0; i < 2; i++) {
            // Тут можна використовувати змінну i:
            System.out.println(i);
        }
//      System.out.println(i);             // а ось тут її уже не існує...

        int i;                             // ...і її можна оголосити в тілі функції...
//      for (int i = 0; i < 2; i++) { }    // ...а якщо вона уже оголошена, її не можна оголосити ще раз в умові циклу
        for (i = 0; i < 2; i++) { }        // ...але її можна використовувати як параметр
        System.out.println(i);             // ...і вона житиме зовні циклу (в даному випадку виведе 2)


        // Це підводить нас до такого поняття як БЛОКИ (про яке я писав багато, але не пояснив, що це таке)
        // і ОБЛАСТЬ ВИДИМОСТІ змінної (константи).

        // У Java весь ВИКОНУВАНИЙ код знаходиться у БЛОКАХ. На найвищому рівні є опис класу - як, наприклад, тут:
        // public class FlowControlsApp { **ТУТ УВЕСЬ ВМІСТ КЛАСУ** }
        //
        // Далі, у класі теж є блоки - вкладені класи і статичні блоки (про ті і інші - згодом), і насамперед методи,
        // як-от даний public static void main(String[] args) { **ТУТ КОД МЕТОДУ** }
        //
        // Усередині методу теж є блоки. Вони можуть бути самі по собі:
        {
            int definedInBlock = 666;
        }
        // але зазвичай це блоки для розгалужень та циклів, як Ви можете бачити з кожного прикладу вище.

        // Правило, яке треба порозуміти і запам’ятати:
        // Змінні і сталі, оголошені у певному блоці, доступні ЛИШЕ у цьому блоці та блоках всередині цього.

        // Це означає, що якщо змінна оголошена у тілі метода, її можна використовувати і всередині розгалужень
        // та циклів:
        int definedInMethodScope = 42;
        if (true) {
            System.out.println(definedInMethodScope);
        }
        for (int j = 0; j < 3; j++) {
            System.out.println(definedInMethodScope);
        }

        // Але якщо змінна оголошена всередині розгалуження чи циклу, до неї не можна доступитися ззовні:
        if (true) {
            int definedInIfStatement = 10;
        }
        for (int j = 0; i < 3; j++) {
            int definedInLoop = 20;
        }

//      System.out.println(definedInBlock);          // змінна із «блоку самого по собі» на рядку 368
//      System.out.println(definedInIfStatement);
//      System.out.println(definedInLoop);           // - нічого з цього не скомпілюється: усі троє - невідомі змінні

        // Із цією особливістю тісно пов’язане поняття ОБЛАСТІ ВИДИМОСТІ змінної.
        // Вищесказане можна перефразувати так: областю видимості змінної є блок, у якому вона оголошена, і всі блоки
        // всередині нього.

        // У одній області видимості НЕ МОЖЕ існувати двох змінних (сталих) із однаковим іменем.
        // Тобто, якщо змінна із певним іменем уже оголошена в методі, не можна створити ще одну змінну
        // із таким же іменем всередині розгалуження або циклу:
        if (true) {
//          int definedInMethodScope = 30;          // не можна - така змінна уже є в методі
        }

        // Для допитливих: через те, що пам’ять під примітиви і об’єкти та масиви виділяється по-різному, час їхнього
        // життя теж відрізняється. Змінні і константи примітивних типів знаходяться у стеку - найшвидшій області
        // пам’яті, прив’язаній до даного блоку, в той час як масиви і об’єкти виділяються у купі (heap), яка є
        // загальною для всієї програми. Коли програма виходить із блоку, верхній елемент стеку (себто, наш блок і
        // пам’ять, прив’язана до нього) руйнується одразу, в той час як посилання на об’єкти і масиви у купі можуть
        // продовжувати жити, якщо вони були передані десь за межі блоку (наприклад, збережені у поле класу).

        // -------------------------------------------------------------------------------------------------------------

        // todo: дописати про нескінченні цикли і оператори break/continue


    }

}
