package com.uzhnu.training.samples.basics;

import java.util.Random;

/**
 * <p>У цьому лістингу пояснюються оператори для побудови алгоритмів (розгалуження і цикли)</p>
 *
 * @author Paul Danyliuk
 * @version $Id$
 */
public class FlowControlsApp {

    /*
    Кожна програма - це, зрештою, набір якихось дій, які виконуються одна за іншою.
    Послідовність дій називається АЛГОРИТМОМ.

    Найпростіший вид алгоритмів - лінійні. Це коли усі дії виконуються одна за іншою від початку програми і до кінця.
    Приклад - програма, яка зчитує Ваше ім’я, Ваш вік і виводить привітання (com.uzhnu.training.samples.HelloApp)

    Проте від лінійних програм користі небагато. Якби калькулятор був лінійним, він би підтримував лише одну операцію,
    і після закінчення обчислень закрився би. Нормальний калькулятор, який підтримує принаймні віднімання, додавання,
    множення і ділення, повинен виконувати різні обчислення в залежності від вибраної користувачем операції: якщо
    користувач натиснув плюс, то треба виконати і вивести суму, якщо мінус - різницю і т.д. Окрім того, нормальний
    калькулятор дозволятиме користувачу робити нові обчислення аж поки користувач його не вимкне (на комп’ютері -
    не натисне кнопку «вихід»).

    Алгоритми, у яких різні дії виконуються або не виконуються залежно від умов, називаються розгалуженими, а шматки
    алгоритму із такими діями - гілками. Програма може виконати одну або іншу гілку, і далі повернутися до спільного
    продовження.

    Алгоритми, у яких дії виконуються знову і знову, називаються циклічними, а шматки алгоритму із такими діями -
    циклами. Цикл може виконуватися скінченну або нескінченну кількість разів - це теж задається умовами.

    Загляньте у com.uzhnu.training.samples.RandomApp - гру, в якій комп’ютер загадує число від 1 до 100, а Вам потрібно
    відгадати його, керуючись підказками. У цій програмі є і цикл, і розгалуження. Цикл тут полягає в тому, що програма
    виконує БЛОК КОДУ (зчитує Ваше число і повідомляє про результат) знову і знову, аж доки Ви не вгадаєте число.
    А розгалуження має три гілки: якщо Ваш варіант менший за загадане число (одна підказка), якщо більший
    (інша підказка), і якщо Ви вгадали число (привітання і вихід із програми).

    Цикли і розгалуження створюються відповідно операторами циклу і операторами розгалуження, які разом мають назву
    операторів потоку керування (control flow operators).

    Фактично, маючи у своєму розпорядженні змінні, масиви, операції над даними, цикли і розгалуження, можна
    запрограмувати розв’язування будь-якої задачі. Можливості деяких академічних мов на цьому і закінчуються.
    */

    public static void main(String[] args) {

        // Щоб було цікавіше, «кинемо» два кубики:
        Random random = new Random();
        int die1 = random.nextInt(6) + 1;        // nextInt(5) генерує ціле число від 0 до 5 включно,
        int die2 = random.nextInt(6) + 1;        // тож щоб отримати від 1 до 6, треба додати одиницю

        System.out.println("На першому кубику випало " + die1 + ", а на другому - " + die2);

        // -------------------------------------------------------------------------------------------------------------

        // 1. Розгалуження
        // У Java та інших сі-подібних мовах є три способи зробити розгалуження.
        // Найпростіший і найбільш поширений - за допомогою оператора if («якщо»), і пишеться так:
        //
        // if (<умова, яка повертає boolean>) {
        //     <код, який виконається, якщо умова true>
        // }

        if (die1 == die2) {
            System.out.println("На кубиках випали однакові числа!");
        }
        // Якщо умова не виконалася (випали різні числа) -
        // програма пропустить цей блок (не виведе повідомлення) і піде далі.

        // -------------------------------------------------------------------------------------------------------------

        // Якщо потрібно виконати якісь альтернативні дії, коли умова НЕ виконалася,
        // використовують оператор else («інакше»):

        if (die1 % 2 == 0) {
            // Умова перевіряє, що число die1 ділиться на 2 без остачі
            System.out.println("На першому кубику випало парне число");
        } else {
            // У всіх інших випадках (точніше, єдиному випадку, коли остача від ділення на 2 буде 1):
            System.out.println("На першому кубику випало непарне число");
        }

        // Але, як показано у попередньому прикладі, блок else не є обов’язковим

        // -------------------------------------------------------------------------------------------------------------

        // Умови можна вкладати одна в одну як завгодно глибоко

        if (die1 < 4) {
            System.out.println("На першому кубику випало від 1 до 3");

            if (die2 < 4) {
                System.out.println("І на другому кубику випало від 1 до 3");
            } else {
                System.out.println("А на другому кубику випало від 4 до 6");
            }
        } else {
            System.out.println("На першому кубику випало від 4 до 6");

            if (die2 < 4) {
                System.out.println("А на другому кубику випало від 1 до 3");
            } else {
                System.out.println("І на другому кубику випало від 4 до 6");
            }
        }

        // -------------------------------------------------------------------------------------------------------------

        // Гілок може бути більше ніж одна. Такі умови задаються послідовно
        // Перевірка умов виконуватиметься по черзі; виконається тільки перший блок, чия умова дорівнюватиме true:

        if (die1 == 1) {
            System.out.println("На першому кубику випало число 1");
        } else if (die1 == 2) {
            System.out.println("На першому кубику випало число 2");
        } else if (die1 == 3) {
            System.out.println("На першому кубику випало число 3");
        } else if (die1 < 4) {
            // Цей блок ніколи не виконається, навіть якщо на кубику випало число менше 4,
            // адже ці варіанти уже перехопили попередні умови

            System.out.println("Я ніколи не виконаюсь!");
        }
        // Тут може бути else - для коду, який виконається, коли випало число від 4 до 6.

        // -------------------------------------------------------------------------------------------------------------

        // Фактично, ці два останні розгалуження можна переписати на рівноцінні:

        // Вкладене на послідовне:
        if (die1 < 4 && die2 < 4) {                                            // пам’ятаємо про ЛОГІЧНЕ І?
            System.out.println("На першому кубику випало від 1 до 3");
            System.out.println("І на другому кубику випало від 1 до 3");
        } else if (die1 < 4 && die2 >= 4) {
            System.out.println("На першому кубику випало від 1 до 3");
            System.out.println("А на другому кубику випало від 4 до 6");
        } else if (die1 >= 4 && die2 < 4) {
            System.out.println("На першому кубику випало від 4 до 6");
            System.out.println("А на другому кубику випало від 1 до 3");
        } else {                                                               // бо більше не лишилося варіантів
            System.out.println("На першому кубику випало від 4 до 6");
            System.out.println("І на другому кубику випало від 4 до 6");
        }

        // Послідовне на вкладене (насправді, змінилося лише форматування і з’явилися фігурні дужки):
        if (die1 == 1) {
            System.out.println("На першому кубику випало число 1");
        } else {
            if (die1 == 2) {
                System.out.println("На першому кубику випало число 2");
            } else {
                if (die1 == 3) {
                    System.out.println("На першому кубику випало число 3");
                } else {
                    if (die1 < 4) {
                        System.out.println("Я ніколи не виконаюсь!");
                    }
                }
            }
        }

        // Як бачите, одну і ту саму логіку можна описати різними способами, тому Ви як програміст повинні приймати
        // рішення, як скласти умову найефективнішим шляхом, і щоб не було ЛАЙНОКОДУ.

        // Порівняйте рівноцінні приклади між собою, і Ви побачите, що приклад із перевіркою на 1-2-3 читається набагато
        // легше коли умови йдуть одна за одною, а не вкладені, а приклад із двома кубиками краще зробити вкладеним,
        // оскільки у іншому випадку виконується набагато більше операцій і є повторення коду.

        // Цікаво знати: насправді, на рівні процесора навіть послідовні розгалуження виконуються як вкладені.
        // Але це не має значення.
        // Зрозумілість і простота коду повинні завжди бути ПРІОРИТЕТОМ НОМЕР 1 !!!

        // -------------------------------------------------------------------------------------------------------------

        // Інший спосіб задання розгалуження - оператор switch/case («перемикач»/«у випадку»).
        // Його синтаксис виглядає наступним чином:

        switch (die2) {
            case 1:
                System.out.println("На другому кубику випало число 1");
                // тут можуть бути інші операції - зверніть увагу, що гілки не обгорнуті у фігурні дужки
                // ...
                break;      // Щоб не спрацювали інші гілки, у кінці «блоку» case треба поставити оператор break!
            case 4:
                System.out.println("На другому кубику випало число 4");
                break;
            case 2:         // Таким чином можна об’єднувати кілька варіантів
            case 3:
                System.out.println("На другому кубику випало 2 або 3");
                break;
            default:
                // Аналогічно до else, блок default іде останнім, виконується тоді, коли не виконалося нічого зверху
                // і може бути відсутнім.
                System.out.println("На другому кубику випало не 1, не 2, не 3 і не 4");
        }
        // У останньому блоку оператор break необов’язковий

        // Як це розуміти?
        // Для значення switch перевіряється його рівність посліднвно кожному зі значень case.
        // Як тільки Java знайде збіг, вона виконуватиме ВЕСЬ код до кінця блоку switch, не зважаючи на інші case.
        // Оператор break зупиняє виконання коду в даному блоці і зумовлює вихід із нього (із блоку).
        // Звісно, break можна і не ставити, якщо це саме те, що Вам потрібно:
        switch (die1) {
            case 1:
                System.out.println("На першому кубику випало 1 або більше");
            case 2:
                System.out.println("На першому кубику випало 2 або більше");
            case 3:
                System.out.println("На першому кубику випало 3 або більше");
            case 4:
                System.out.println("На першому кубику випало 4 або більше");
            case 5:
                System.out.println("На першому кубику випало 5 або більше");
            case 6:
                System.out.println("На першому кубику випало 6 або більше");
        }

        // Оператори switch/case працюють із такими типами даних:
        // - цілочисельними примітивами: byte, short, int (але не long)
        // - літерами (char)
        // - класами-обгортками над цими примітивами (Character, Byte, Short, Integer)
        // - класами-перечисленнями (енумераторами) - їх ми ще не розглядали
        // - починаючи із Java 7 - рядками (String)

        // Знову ж таки, вибір між розгалуженнями if/else і switch/case Ви здійснюєте на власний розсуд,
        // в залежності від того, який код краще сприймається.

        // -------------------------------------------------------------------------------------------------------------

        // Третій спосіб створення розгалужень - тернарний оператор ?: (умовний оператор)
        // Досі ми розглядали унарні оператори (один операнд) типу i++ і бінарні оператори (два операнди) типу a + b
        // Тернарні оператори приймають ТРИ операнди, і насправді я не знаю, чи існують інші тернарні оператори крім ?:

        // Умовний оператор повертає одне зі значень в залежності від умови. Синтаксис виглядає так:
        // <умова, яка повертає boolean> ? <значення, якщо true> : <значення, якщо false>
        System.out.println(die1 == die2 ? "рівні" : "різні");

        int difference = die1 > die2 ? die1 - die2 : die2 - die1;   // Якщо значення першого кубика більше за значення
                                                                    // другого - відняти від першого друге, інакше -
                                                                    // від другого перше.
        System.out.println("Різниця між значеннями кубиків - " + difference);

        // Тернарний оператор можна використовувати каскадом (один в іншому):
        System.out.println(
                die1 == die2 ? "рівні" : die1 > die2 ? "перший більше" : "другий більше"
        );

        // Як бачите, такий оператор хоч і дозволяє компактно записати умову, об такі вирази буває легко зламати очі.
        // Тому використовувати цей оператор треба дуже обережно, там де він дійсно полегшить розуміння коду.

        // -------------------------------------------------------------------------------------------------------------

        // 2. Цикли

        // todo: допишу згодом

    }

}
