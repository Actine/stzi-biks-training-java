package com.uzhnu.training.samples.basics;

import java.util.Arrays;

/**
 * <p>У цьому прикладі пояснюються масиви даних</p>
 *
 * @author Paul Danyliuk
 * @version $Id$
 */
public class ArraysApp {

    public static void main(String[] args) {

        // Гаразд, ми розібралися із типами даних, змінними, константами і т.д. Число, рядок, булеве значення тощо -
        // це файно, але ж документ складається не з одного, а з багатьох рядків тексту, матриця - із багатьох чисел,
        // картинка - із багатьох пікселів, зрештою, файл - із багатьох байтів!

        // Невже на кожен рядок, число, піксель і байт потрібно виділяти нову змінну?

        // Звісно що ні.

        // Адресувати великі блоки однотипних даних покликані МАСИВИ, які існують у переважній більшості сучасних мов.

        // Масив (array) - це структура даних, яка дозволяє зберегти задану кількість змінних. Доступ до кожної із цих
        // змінних (ЕЛЕМЕНТІВ масиву) здійснюється через спільне ім’я масиву і індекс окремого елемента:

        String[] names = new String[3];         // Створили масив під назвою names, що складається із трьох рядків
        names[0] = "Павло";                     // Присвоїли значення першому елементу
        names[1] = "Тарас";                     // Присвоїли значення другому елементу
        names[2] = "Володимир";                 // Присвоїли значення третьому елементу

        System.out.println(names[0] + ", " + names[1] + " і " + names[2]);     // "Павло, Тарас і Володимир"

//      System.out.println(names[3]);           // програма рухне з помилкою - індекс 3 виліз за межі масиву (0, 1, 2)

        // Перше ж питання: чому індекси починаються з нуля?
        // Відповідь: так склалося історично, що елементи масиву ідентифікуються не за їхнім порядковим номером,
        // а за ЗСУВОМ від початку масиву.

        // Спробую пояснити.

        // Пам’ятаєте, що змінні-об’єкти насправді зберігають посилання на комірку пам’яті, де знаходиться об’єкт?
        // Із масивами така ж ситуація.
        // Зазвичай під масив виділяється неперервний блок пам’яті, величина якого = місце, необхідне для зберігання
        // одного елемента, помножене на кількість елементів. Сама же змінна-масив (наприклад, names) указує на початок
        // масиву.
        // Якщо припустити, що масив починається за адресою 2000, а кожен елемент займає 4 байти,
        // то 1-й елемент (names[0]) знаходитиметься за адресою 2000, 2-й (names[1]) - за адресою 2004,
        // 3-й (names[2]) - за адресою 2008 і т.д., тобто адреса для елемента names[x] визначається як 2000 + 4*x.
        // Через це нумерацію x зручно починати з нуля.

        // У багатьох мовах програмування, включаючи C++ і Java, масиви мають СТАЛИЙ РОЗМІР, який задається при його
        // оголошенні. Масив, як і змінна, може мати значення конкретно одного типу, який для нього заданий -
        // зокрема це гарантує те, що зсув між усіма елементами масиву буде однаковим.

        // Масив може виділятися під примітиви (в такому випадку в масиві одразу знаходяться значення цих примітивів),
        // або і під об’єкти (як наш names, який виділений під рядки) - тоді елементами масиву будуть посилання
        // на об’єкти (точно так само, як і зі змінними), які самі знаходяться у пам’яті десь у зовсім іншому місці.
        // У Java на масив можна теж дивитися як на тип даних.
        // Для тих, хто паралельно вчить C++ - ситуація там схожа, але механізм роботи масивів інший.

        // До слова, текстові дані типу String теж зберігаються у масиві - масиві літер char[]

        // -------------------------------------------------------------------------------------------------------------

        // Гаразд, розберемося із оголошенням.

        // Синтаксис для оголошення масиву:
        // <тип>[] <ім’я> (або <тип> <ім’я>[], але прийнято використовувати перший)
        int[] myInts;
        double[] myDoubles;
        Object[] myObjects;
        long myLongs[];        // можна і так, але на Java звикли відносити [] до типу

        // Синтаксис для ініціалізації масиву:
        // new <тип>[розмір]
        myInts = new int[10];        // створить новий масив для 10 елементів типу int

        // Як і зі змінними, оголошення і ініціалізацію можна (і слід) об’єднувати:
        boolean[] booleans = new boolean[100];

        // Крім того, якщо одразу відомі елементи масиву, замість указання розміру можна їх перелічити наступним чином:
        // new <тип>[]{елемент1, елемент2, ... , елементN}

        int[] diceNumbers = new int[]{1, 2, 3, 4, 5, 6};    // створить новий масив із 6 цілих чисел
                                                            // і зразу заповнить його значеннями
        System.out.println(diceNumbers[0]);      // 1
        System.out.println(diceNumbers[1]);      // 2
        System.out.println(diceNumbers[2]);      // 3
        System.out.println(diceNumbers[3]);      // 4
        System.out.println(diceNumbers[4]);      // 5
        System.out.println(diceNumbers[5]);      // 6

        // Або навіть ще простіше - без new <тип>[] (хоча цей спосіб використовують рідко)
        int[] secondDiceNumbers = {1, 2, 3, 4, 5, 6};

        // Коли створюється масив із примітивів, кожен елемент масиву заповнюється початковим значенням даного типу.
        // Для чисел це 0, для булінів - false, для літер (char) - нульовий символ.
        myLongs = new long[3];
        System.out.println(myLongs[0]);   // 0
        System.out.println(myLongs[1]);   // 0
        System.out.println(myLongs[2]);   // 0

        // Масиви із об’єктів заповнюються пустими вказівниками - null.
        myObjects = new Object[3];
        System.out.println(myObjects[0]);   // null
        System.out.println(myObjects[1]);   // null
        System.out.println(myObjects[2]);   // null

        // Можна створити масив із нулем елементів.
        int[] emptyArray = new int[0];

        // Може здатися, що в ньому немає сенсу, але насправді інколи це дуже зручно.
        // Подивіться у оголошення цього метода public static void main(String[] args)
        // Ось у нього є параметр String[] для аргументів. Як гадаєте, що туди передається, коли параметрів нема?
        // Правильно, String[0]

        // -------------------------------------------------------------------------------------------------------------

        // У будь-якого (навіть у пустого) масиву можна дізнатися його довжину:
        System.out.println(diceNumbers.length);    // 6
        System.out.println(emptyArray.length);     // 0

        // І взагалі насправді масиви теж є об’єктами (а сам тип «масив» - класом-дженеріком, але про це згодом).
        // У масивів є традиційні для усіх об’єктів методи, такі як toString і equals()
        // ...хоча роблять вони не зовсім те, що від них очікуєш
        System.out.println(diceNumbers.toString());     // А от і не виведе він вміст масиву,
                                                        // а виведе натомість ідентифікатор на кшталт [I@1540e19d

        System.out.println(diceNumbers.equals(secondDiceNumbers));      // Хоч ці масиви містять однакові елементи,
                                                                        // результат буде false (чомусь equals у масивів
                                                                        // працює як == у об’єктів, тобто порівнює
                                                                        // не вміст, а посилання на комірку пам’яті)

        // Для гарного виведення вмісту масиву у рядок можна використовувати такий метод:
        System.out.println(Arrays.toString(diceNumbers));     // [1, 2, 3, 4, 5, 6]

        // А для порівняння - такий:
        System.out.println(Arrays.equals(diceNumbers, secondDiceNumbers));     // true

        // І взагалі, в утилітному класі Arrays - багато корисних методів для роботи із масивами,
        // зокрема для їх сортування різними способами, пошуку елементів, заповнення даними і т.д.
        int[] arrayToFill = new int[100];
        Arrays.fill(arrayToFill, 5);                          // заповнить всі 100 елементів значенням 5

        int[] arrayToSort = new int[]{5, 3, 10, 1, -6};
        Arrays.sort(arrayToSort);                             // відсортує масив за зростанням
        System.out.println(Arrays.toString(arrayToSort));     // [-6, 1, 3, 5, 10]

        // -------------------------------------------------------------------------------------------------------------

        // І, зрештою, масив може бути не тільки одновимірним, але і багатовимірним
        // (масивом масивів, масивом масивів масивів... і чим далі, тим МЕНШ ЕФЕКТИВНИМ він буде)
        int[][] smallMatrix = new int[2][2];
        smallMatrix[0] = new int[]{1, 2};
        smallMatrix[1] = new int[]{5, 1};

        // Або простіше:
        int[][] anotherMatrix = {{1, 2}, {5, 1}};

        // Порахуємо визначник цієї матриці ^_^
        int determinant = smallMatrix[0][0] * smallMatrix[1][1] - smallMatrix[0][1] * smallMatrix[1][0];
        System.out.println(determinant);

        // Цей самий приклад із матрицею і визначником можна вирішити і без двовимірних масивів:
        int[] sameSmallMatrix = new int[]{1, 2, 5, 1};
        determinant = sameSmallMatrix[0] * sameSmallMatrix[3] - sameSmallMatrix[1] * sameSmallMatrix[2];
        System.out.println(determinant);

        // Тому старайтеся спрощувати і обходитись одновимірними масивами.

        // Поки що все, згодом цей лістинг буде доповнено.

    }

}
