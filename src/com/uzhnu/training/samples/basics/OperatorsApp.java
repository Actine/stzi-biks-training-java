package com.uzhnu.training.samples.basics;

/**
 * <p>Програма розглядає найпоширеніші математичні і логічні операції</p>
 *
 * @author Paul Danyliuk
 * @version $Id$
 */
public class OperatorsApp {

    // Очевидно, що від простого зберігання даних у пам’яті користі небагато.
    // Жодна програма, яка робить щось осмислено корисне, не обходиться без перетворення цих даних, операцій над ними

    public static void main(String[] args) {

        // 1. Математичні операції
        // Їх можна здійснювати ЛИШЕ над примітивними числовими типами і їх класами-обгортками (адже вони автоматично
        // розгорнуться, пам’ятаєте?)

        // Бінарні ОПЕРАЦІЇ (два ОПЕРАНДИ)
        System.out.println(12 + 34);        // 46
        System.out.println(12 - 34);        // -22
        System.out.println(12 * 34);        // 408
        System.out.println(12 / 34);        // 0
                                            // При діленні цілого числа на ціле число результатом теж буде ціле число.
                                            // Дробна частина частки просто відкидається, тож 1/2 = 0, 3/2 = 1 і т.д.

        System.out.println(12.0 / 34);      // Щоб результат операції був дробним числом (типу double або float),
        System.out.println(12 / 34.0);      // принаймні один із операнди повинен бути double або float відповідно.
        System.out.println(12d / 34);       // Усі ці приклади виведуть 0.35294117647058826

        // Результат операції над двома операндами матиме тип «найширшого» операнда (із найширшою множиною значень):
        // int < long < float < double
        // Операції над типами byte і short завжди даватимуть int
        System.out.println((byte)5 + (byte)10);     // int
        System.out.println(5 + 10);                 // int
        System.out.println(5 + 10L);                // long
        System.out.println(5f + 10f);               // float
        System.out.println(5f + 10d);               // double

        // Іще одна бінарна математична операція - взяття за модулем
        // Вона повертає остачу від ділення націло:
        System.out.println(0 % 4);          // 0
        System.out.println(1 % 4);          // 1
        System.out.println(2 % 4);          // 2
        System.out.println(3 % 4);          // 3
        System.out.println(4 % 4);          // 0
        System.out.println(5 % 4);          // 1
        System.out.println(6 % 4);          // 2
                                            // ...

        // Унарні операції (один операнд)
        // Їх є чотири, вони працюють лише для числових змінних (і цілих, і дробних теж) і одразу змінюють їх
        int i = 0;
        System.out.println(i++);            // 0 - Повернути нинішнє значення i, тоді збільшити його на 1
        System.out.println(i--);            // 1 - Повернути нинішнє значення i, тоді зменшити його на 1
        System.out.println(++i);            // 1 - Спершу збільшити значення на 1, тоді повернути результат
        System.out.println(--i);            // 0 - Спершу зменшити значення на 1, тоді повернути результат

        // Операції можна комбінувати. Порядок їх виконання звичний: зліва направо, унарні операції ідуть першими,
        // множення і ділення виконується перед додаванням і відніманням, можна використовувати дужки,
        // можна ставити мінус перед змінними:
        System.out.println((2.5 * ++i) / (i++ * -4));
        System.out.println(-i);

        // -------------------------------------------------------------------------------------------------------------

        // Багато широковживаних математичних операцій знаходяться в УТИЛІТНОМУ класі Math:
        System.out.println(Math.sin(Math.PI / 6));     // pi/6 = 30°, sin(30°) = 0.5
        System.out.println(Math.sqrt(16));             // 4.0 - квадратний корінь
        System.out.println(Math.pow(2, 8));            // 2^8 = 256.0 - піднесення до степеня
        System.out.println(Math.log(Math.E));          // ln(e) = 1.0 - натуральний логарифм
        System.out.println(Math.log10(1000));          // log(1000) = 3.0 - десятковий логарифм
        System.out.println(Math.round(2.5));           // 3 - округлення до найближчого цілого
        System.out.println(Math.floor(2.5));           // 2.0 - округлення до найближчого цілого, меншого за аргумент
        System.out.println(Math.ceil(2.1));            // 3.0 - округлення до найближчого цілого, більшого за аргумент
                                                       // і т.д.

                                                       // зверніть увагу: floor і ceil повертають double, а не int

        System.out.println((int) Math.floor(2.5));     // 2
        System.out.println((int) Math.ceil(2.1));      // 3 - ось так краще

        // Чому ми не створюємо об’єкт класу Math, а викликаємо методи прямо через Math.<ім’я метода>?
        // - Тому що цей клас створений як утилітний («клас-парасолька»), і його задача - просто зібрати
        // методи одної категорії (математичні) під одним дахом.
        // Окрім того, «об’єкт типу Math» не має змісту - математика єдина у всьому світі, як поняття.
        // Тому усі методи класу Math - статичні (тобто, належать самому класу, а не його об’єктам), і викликаються
        // не через <об’єкт>.<метод>(), а через <Клас>.<метод>()

        // Крім того, як Ви могли помітити, у класу Math є не тільки методи:
        System.out.println(Math.PI);        // число π - відношення довжини кола до діаметра
        System.out.println(Math.E);         // число e - основа натурального логарифму

        // Клас і об’єкти класу так само можуть мати сталі і змінні (називаються ПОЛЯМИ класу)
        // Але про них згодом. Просто майте на увазі, що у класів і об’єктів бувають не тільки методи.

        // -------------------------------------------------------------------------------------------------------------

        // 2. Операції порівняння (РЕЛЯЦІЙНІ оператори, від англ. relation - відношення)
        // Завжди повертають результат boolean (так/ні)
        boolean result;

        // Перевірка на рівність (дорівнює, не дорівнює).
        // Можна зрівнювати:
        // - числа з числами (цілі і дробні, АЛЕ НЕ ЇХ ОБГОРТКИ, бо вони є об’єктами)
        // - буліни з булінами
        // - літери (чари) з чарами
        // - об’єкти із null
        // НЕ МОЖНА ЗРІВНЮВАТИ ОБ’ЄКТИ МІЖ СОБОЮ (див. VariablesApp, рядок 328)
        result = 5 == 2;            // false
        result = 5 != 2;            // true
        result = false == true;     // false
        result = 'A' == 'A';        // true

        result = "Привіт" == "Привіт";   // НЕ РОБІТЬ ТАК!
                                         // У загальному випадку, об’єкти завжди будуть не рівні між собою

        // Як уже було сказано, для порівняння об’єктів використовується метод equals, який є у всіх об’єктів
        result = "Привіт".equals("Привіт");        // true
        result = "Привіт".equals("Бувай");         // false
        result = new Integer(10).equals("10");     // false, бо число 10 і рядок "10" - різні речі

        // Порівнювати на меншість/більшість можна тільки числа.
        result = 5 < 2;             // Менше. 5 не менше 2, отже false
        result = 5 > 2;             // Більше. Все правильно, отже true
        result = 5 <= 2;            // Менше або рівне
        result = 5 >= 2;            // Більше або рівне

        // Тут можна підставляти і класи-обгортки - вони автоматично розгорнуться
        Integer a = 5;
        Integer b = 10;
        result = a < b;         // true
        result = a == b;        // а ось таке робити не можна, тому що воно буде порівнювати посилання на об’єкти,..
        result = a.equals(b);   // ...натомість треба так

        // -------------------------------------------------------------------------------------------------------------

        // 3. Логічні операції
        // Здійснюються над булінами (логічними «так» (true) і «ні» (false))
        boolean x = true;
        boolean y = false;

        result = !result;           // Заперечення: «так» стає «ні», «ні» стає «так»
        System.out.println(!false);            // true;
        System.out.println(!true);             // false;

        result = x && y;            // Кон’юнкція (операція І):
                                    // результат буде true тільки якщо І перший, І другий операнди будуть true:
        System.out.println(false && false);    // false;
        System.out.println(false && true);     // false;
        System.out.println(true  && false);    // false;
        System.out.println(true  && true);     // true;

        result = x || y;            // Диз’юнкція (операція АБО):
                                    // результат буде true якщо перший АБО другий (АБО обидва) операнди будуть true:
        System.out.println(false || false);    // false;
        System.out.println(false || true);     // true;
        System.out.println(true  || false);    // true;
        System.out.println(true  || true);     // true;

        result = x ^ y;             // Виключна диз’юнкція (ВИКЛЮЧНЕ АБО), або логічне додавання:
                                    // результат буде true лише якщо один із операндів true, але не обидва разом:
        System.out.println(false ^ false);     // false;
        System.out.println(false ^ true);      // true;
        System.out.println(true  ^ false);     // true;
        System.out.println(true  ^ true);      // false;

        // Логічні операції найкраще працюють тоді, коли треба перевіряти зразу кілька умов:..
        result = i > 5 && i < 10;   // true якщо змінна більше 5 І менше 10
        result = i < 5 || i > 10;   // true якщо змінна менше 5 АБО більше 10

        // Багато умов:..
        result = i == 10 || i == 14 || i == 27 || i == 45;         // true, якщо змінна рівна одному із цих чисел

        // ВАЖЛИВО:
        // Логічні операції, як і математичні, виконуються зліва направо, якщо немає дужок.
        // Якщо результат операції відомий раніше, ніж виконається увесь вираз, Java не виконуватиме решту.
        // Наприклад, у останньому прикладі, якщо змінна дорівнює 10, нема сенсу перевіряти інші умови

        // Проілюструємо наступним чином
        int variable = 0;
        result = ++variable == 1 || ++variable == 2 || ++variable == 3 || i > 0;

        System.out.println(variable);   // 1
                                        // Чому так сталось, адже variable мала збільшитись на одиницю тричі?
                                        // Тому що перша умова (++variable == 1) повернула true, а отже результат буде
                                        // true незалежно від того, що повернуть інші перевірки. Тому Java не виконує їх

        // Те саме, якщо є оператор І, і перша же перевірка повертає false:
        result = ++variable == 1 && ++variable > 0 && ++variable > 1;

        System.out.println(variable);   // 2 - виконалося лише ++variable == 1

        // Це корисно пам’ятати для оптимізації коду: старайтеся складати умови так, щоби результат повертався чимшвидш,
        // а операцій виконувалось щонайменше.

        // І НЕ ЗМІНЮЙТЕ ЗНАЧЕНЬ ЗМІННИХ У ПОРІВНЯННЯХ!

        // Детальніше про логічні операції: https://uk.wikipedia.org/wiki/Логічний_сполучник

        // -------------------------------------------------------------------------------------------------------------

        // 4. Побітові операції і побітовий зсув (bit shift)
        // Ця секція скоріше для допитливих.

        // Побітові операції здійснюються над цілими числами.
        // Це як логічні операції над окремими бітами, де 0 - false, а 1 - true:
        System.out.println(0b0011 & 0b0101);     // 0b0001, себто 3 & 5 = 1 - побітове І
        System.out.println(0b0011 | 0b0101);     // 0b0111, себто 3 | 5 = 7 - побітове АБО
        System.out.println(0b0011 ^ 0b0101);     // 0b0110, себто 3 ^ 5 = 6 - побітове ВИКЛЮЧНЕ АБО

        // Є ще побітове заперечення, але слід мати на увазі, що заперечуватися будуть усі 32 розряди:
        System.out.println(
                Integer.toBinaryString(~0b01101010000000000000000000000011)
        );                             // 10010101111111111111111111111100

        // Крім цього, існують побітовий зсув вліво і зсув вправо:
        System.out.println(0b0011 << 1);         // вліво на 1 розряд - буде 0b0110, себто 3 << 1 = 6
        System.out.println(0b0011 << 2);         // вліво на 2 розряди - буде 0b1100, себто 3 << 2 = 12
        System.out.println(0b1100 >> 1);         // вправо на 1 розряд - буде 0b0110, себто 12 >> 1 = 6

        // Оскільки найстарший біт (перший зліва) завжди відповідає за знак (1 - від’ємне число), для зсуву вправо є
        // два оператори
        System.out.println(-12 >> 1);      // вправо на 1 розряд зі збереженням знака - буде -6
        System.out.println(-12 >>> 1);     // вправо на 1 розряд без збереження знака - буде 2147483642
                                           // (одиничка із мінуса перетвориться на 31-й біт, а на місці мінуса буде 0)

        // Так краще видно:
        System.out.println(Integer.toBinaryString(-12 >> 1));    // 11111111111111111111111111111010
        System.out.println(Integer.toBinaryString(-12 >>> 1));   // 01111111111111111111111111111010

        // Розряди, які вилізли за межі числа, ігноруються. Вільні місця заповнюються нулями.

        // Як ви, можливо, помітили - зсув на N позицій вліво/вправо еквівалентний цілочисельному множенню/діленню
        // на 2 у степені N

        // -------------------------------------------------------------------------------------------------------------

        // 5. Операції над рядками
        // У рядків є лише одна операція - з’єднання:
        String concat = "Привіт" + ", " + "студенте!";      // Привіт, студенте!

        // Проте насправді вона існує лише «віртуально» - насправді, цей код «під капотом» заміняється наступним:
        concat = new StringBuilder(17).append("Привіт").append(", ").append("студенте!").toString();

        // Тому, в принципі, додавати рядки можна, але у деяких випадках (наприклад, якщо до рядка дописуються інші
        // рядки у циклі) його треба уникати, а натомість використовувати StringBuilder явно.

        // -------------------------------------------------------------------------------------------------------------

        // Числові і бітові операції можна здійснювати одразу із присвоєнням:
        int num = 10;
        num += 5;       // еквівалентно num = num + 5;
        num -= 5;       // еквівалентно num = num - 5;
        num *= 5;       // еквівалентно num = num * 5;
        num /= 5;       // еквівалентно num = num / 5;
        num &= 5;       // еквівалентно num = num & 5;
        num |= 5;       // еквівалентно num = num | 5;
        num %= 5;       // еквівалентно num = num % 5;
        num <<= 1;      // еквівалентно num = num << 1;
        num >>= 1;      // еквівалентно num = num >> 1;
        num >>>= 1;     // еквівалентно num = num >>> 1;

        // -------------------------------------------------------------------------------------------------------------

        // У деяких мовах (напр. С++) функції операторів можна визначати і перевизначати для своїх типів.
        // У Java оце все, що є - для операцій над об’єктами класів використовуються суто методи.

        // Ну ось у принципі і все

    }

}
