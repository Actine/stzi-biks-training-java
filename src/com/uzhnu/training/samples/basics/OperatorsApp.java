package com.uzhnu.training.samples.basics;

/**
 * <p>Програма розглядає найпоширеніші математичні і логічні операції</p>
 *
 * @author Paul Danyliuk
 * @version $Id$
 */
public class OperatorsApp {

    // Очевидно, що від простого зберігання даних у пам’яті користі небагато.
    // Жодна програма, яка робить щось осмислено корисне, не обходиться без перетворення цих даних, операцій над ними

    public static void main(String[] args) {

        // 1. Математичні операції
        // Їх можна здійснювати ЛИШЕ над примітивними числовими типами і їх класами-обгортками (адже вони автоматично
        // розгорнуться, пам’ятаєте?)

        // Бінарні ОПЕРАЦІЇ (два ОПЕРАНДИ)
        System.out.println(12 + 34);        // 46
        System.out.println(12 - 34);        // -22
        System.out.println(12 * 34);        // 408
        System.out.println(12 / 34);        // 0
                                            // При діленні цілого числа на ціле число результатом теж буде ціле число.
                                            // Дробна частина частки просто відкидається, тож 1/2 = 0, 3/2 = 1 і т.д.

        System.out.println(12.0 / 34);      // Щоб результат операції був дробним числом (типу double або float),
        System.out.println(12 / 34.0);      // принаймні один із операнди повинен бути double або float відповідно.
        System.out.println(12d / 34);       // Усі ці приклади виведуть 0.35294117647058826

        // Результат операції над двома операндами матиме тип «найширшого» операнда (із найширшою множиною значень):
        // int < long < float < double
        // Операції над типами byte і short завжди даватимуть int
        System.out.println((byte)5 + (byte)10);     // int
        System.out.println(5 + 10);                 // int
        System.out.println(5 + 10L);                // long
        System.out.println(5f + 10f);               // float
        System.out.println(5f + 10d);               // double

        // Іще одна бінарна математична операція - взяття за модулем
        // Вона повертає остачу від ділення націло:
        System.out.println(0 % 4);          // 0
        System.out.println(1 % 4);          // 1
        System.out.println(2 % 4);          // 2
        System.out.println(3 % 4);          // 3
        System.out.println(4 % 4);          // 0
        System.out.println(5 % 4);          // 1
        System.out.println(6 % 4);          // 2
                                            // ...

        // Унарні операції (один операнд)
        // Їх є чотири, і вони працюють лише для числових змінних (і цілих, і дробних теж)
        int i = 0;
        System.out.println(i++);            // 0 - Повернути нинішнє значення i, тоді збільшити його на 1
        System.out.println(i--);            // 1 - Повернути нинішнє значення i, тоді зменшити його на 1
        System.out.println(++i);            // 1 - Спершу збільшити значення на 1, тоді повернути результат
        System.out.println(--i);            // 0 - Спершу зменшити значення на 1, тоді повернути результат

        // Операції можна комбінувати. Порядок їх виконання звичний: зліва направо, унарні операції ідуть першими,
        // множення і ділення виконується перед додаванням і відніманням, можна використовувати дужки,
        // можна ставити мінус перед змінними:
        System.out.println((2.5 * ++i) / (i++ * -4));
        System.out.println(-i);

        // -------------------------------------------------------------------------------------------------------------

        // Багато широко вживаних математичних операцій знаходяться в УТИЛІТНОМУ класі Math:
        System.out.println(Math.sin(Math.PI / 6));     // pi/6 = 30°, sin(30°) = 0.5
        System.out.println(Math.sqrt(16));             // 4.0 - квадратний корінь
        System.out.println(Math.pow(2, 8));            // 2^8 = 256.0 - піднесення до степеня
        System.out.println(Math.log(Math.E));          // ln(e) = 1.0 - натуральний логарифм
        System.out.println(Math.log10(1000));          // log(1000) = 3.0 - десятковий логарифм
        System.out.println(Math.round(2.5));           // 3 - округлення до найближчого цілого
        System.out.println(Math.floor(2.5));           // 2.0 - округлення до найближчого цілого, меншого за аргумент
        System.out.println(Math.ceil(2.1));            // 3.0 - округлення до найближчого цілого, більшого за аргумент
                                                       // і т.д.

                                                       // зверніть увагу: floor і ceil повертають double, а не int

        System.out.println((int) Math.floor(2.5));     // 2
        System.out.println((int) Math.ceil(2.1));      // 3 - ось так краще

        // Чому ми не створюємо об’єкт класу Math, а викликаємо методи прямо через Math.<ім’я метода>?
        // - Тому що цей клас створений як утилітний («клас-парасолька»), і його задача - просто зібрати
        // методи одної категорії (математичні) під одним дахом.
        // Окрім того, «об’єкт типу Math» не має змісту - математика єдина у всьому світі, як поняття.
        // Тому усі методи класу Math - статичні (тобто, належать самому класу, а не його об’єктам), і викликаються
        // не через <об’єкт>.<метод>(), а через <Клас>.<метод>()

        // Крім того, як Ви могли помітити, у класу Math є не тільки методи:
        System.out.println(Math.PI);        // число π - відношення довжини кола до діаметра
        System.out.println(Math.E);         // число e - основа натурального логарифму

        // Клас і об’єкти класу так само можуть мати сталі і змінні (називаються ПОЛЯМИ класу)
        // Але про них згодом. Просто майте на увазі, що у класів і об’єктів бувають не тільки методи.

        // -------------------------------------------------------------------------------------------------------------

        // 2. Операції порівняння
        // Завжди повертають результат boolean (так/ні)
        boolean result;

        // Перевірка на рівність (дорівнює, не дорівнює).
        // Можна зрівнювати:
        // - числа з числами (цілі і дробні, АЛЕ НЕ ЇХ ОБГОРТКИ, бо вони є об’єктами)
        // - буліни з булінами
        // - літери (чари) з чарами
        // - об’єкти із null
        // НЕ МОЖНА ЗРІВНЮВАТИ ОБ’ЄКТИ МІЖ СОБОЮ (див. VariablesApp, рядок 320)
        result = 5 == 2;            // false
        result = 5 != 2;            // true
        result = false == true;     // false
        result = 'A' == 'A';        // true

        result = "Привіт" == "Привіт";   // НЕ РОБІТЬ ТАК!
                                         // У загальному випадку, об’єкти завжди будуть не рівні між собою

        // Як уже було сказано, для порівняння об’єктів використовується метод equals, який є у всіх об’єктів
        result = "Привіт".equals("Бувай");     // false

        // Порівнювати на меншість/більшість можна тільки числа.
        // Тут можна підставляти і класи-обгортки - вони автоматично розгорнуться
        result = 5 < 2;             // Менше, false
        result = 5 > 2;             // Більше, true
        result = 5 <= 2;            // Менше або рівне
        result = 5 >= 2;            // Більше або рівне

        result = Integer.valueOf(5) < Integer.valueOf(10);   // true

        // -------------------------------------------------------------------------------------------------------------

        // 3. Логічні операції
        // Здійснюються над булінами (логічними «так»/«ні»)
        result = !result;           // Заперечення: «так» стає «ні», «ні» стає «так»
        result = true && false;     // Кон’юнкція (операція І): результат буде «так» тільки якщо обидва операнди «так»
        result = true || false;     // Диз’юнкція (операція АБО): результат буде «ні» тільки якщо обидва операнди «ні»
        result = true ^ false;      // Виключна диз’юнкція (ВИКЛЮЧНЕ АБО):
                                    // результат буде «так» лише якщо один із операндів «так»

    }

}
